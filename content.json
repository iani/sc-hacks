{"meta":{"title":"SC Hacks","subtitle":"SC code step-by-step","description":"Gradually introducing recipes from previous SuperCollider libraries","author":"Iannis Zannos","url":"http://iani.github.io"},"pages":[{"title":"About SC-Hacks","date":"2017-06-04T15:29:22.000Z","updated":"2017-06-13T12:45:45.000Z","comments":true,"path":"about/index.html","permalink":"http://iani.github.io/about/index.html","excerpt":"","text":"In this repository, I will review the techniques developed in my libraries for SuperCollider tiny-sc and tiny-inc. I will try to build a cleaner structure step-by-step, and reducing the code to essential features, as far as possible. The code is available in this repository: sc-hacks"},{"title":"categories","date":"2017-06-06T07:27:47.000Z","updated":"2017-06-06T07:28:59.000Z","comments":true,"path":"categories/index.html","permalink":"http://iani.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-06T07:24:32.000Z","updated":"2017-06-06T07:25:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://iani.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Improving Function:eplay","slug":"ImprovingEplay","date":"2017-06-13T12:51:56.000Z","updated":"2017-06-13T13:14:08.000Z","comments":true,"path":"2017/06/13/ImprovingEplay/","link":"","permalink":"http://iani.github.io/2017/06/13/ImprovingEplay/","excerpt":"Individual improvement steps for Function:eplay: Done and TODO.","text":"Individual improvement steps for Function:eplay: Done and TODO. Done (11 Jun 2017 21:48) Store the resulting synth in envir under [\\synths, synthName] (default for synthName: synth). If previous synth exists under [\\synths, synthName] path, then free/release it. When a synth ends, remove it from its path in envir. Make sure that when a synth previousSynth is released by replacing it through a new synth created through Function:eplay, the previousSynth ending does not remove the new synth that has already been stored in the same path. Notification actions for updates from enviroment variable changes are added when the Synth starts (not when the Function:play message is sent). This way, there are no more errors \"Node not found\" when changing the environment before the synth has started. Stil TODO (11 Jun 2017 21:48) Synth start-stop (release) and set control from Event:eplay (EventPatterns) In addition to listening for changes from the currentEnvironment, a second notification mechanism should be added to Function:eplay, to enable creating new synths, releasing or freeing this synth when playing EventPatterns with an EventStreamPlayer. These changes are to be triggered through a function stored in Event default parent, in response to keys produced by a Stream in the Event beying played. Here aee some considerations for designing this feature: The messages sent to effect the changes can be defined arbitrarily. However, it is important to determine who emits the messages (the notifier) and who listens to them (the listener). The notifier has to be someone different than the event playing, because we want to be able to play independently different synths from the same event. The listener cannot be the synth, because sometimes a new synth must be created to continue a line that no longer has a playing synth. One first draft would use the symbol under which a function is played with eplay as both notifier and listener: name \\newSynth name name \\release name name \\set name Synth start-stop notifications for GUI and other listeners When a new synth starts or when an old synth is removed, it should emit notifications so that GUIS that depend on it update their status. Such guis may be: Start-stop buttons Guis with widgets for controlling the synths parameters. When a new synth starts, then the old gui should be replaced with a new one with widgets corresponding to the new synth's control parameters. Note: Possibly the notification should be emitted from the \\synthName under which the synth is stored. The messages may be: \\started \\stopped \\replaced The above is subject to testing. Notes When this is done, it should be possible to create multiple gui windows for multiple synths running in the same environment. However, parameters under the same name will control the parameters under that name for all synths in that environment. To develop the right code for this, do it with a plain function, adding the functionalities one-by-one. Current Function:eplay method code + Function {&#10;&#9;eplay { | name = \\synth, envir |&#10;&#9;&#9;var synth;&#10;&#9;&#9;envir = envir.asEnvironment;&#10;&#9;&#9;Registry.doIfFound (envir, \\synths, name, { | oldSynth |&#10;&#9;&#9;&#9;oldSynth.objectClosed; // prevent removal of successor on end&#10;&#9;&#9;&#9;oldSynth.release(envir [\\releaseTime] ? 0.02);&#10;&#9;&#9;});&#10;&#9;&#9;envir use: {&#10;&#9;&#9;&#9;var argNames, args;&#10;&#9;&#9;&#9;argNames = this.def.argNames;&#10;&#9;&#9;&#9;/* assume that the func uses a gate argument&#10;&#9;&#9;&#9;&#9;Later devise a way to get all the actual controls from the synthdef after it has loaded&#10;&#9;&#9;&#9;*/&#10;&#9;&#9;&#9;args = (argNames ++ ['gate']).collect ({ | name |&#10;&#9;&#9;&#9;&#9;[name, envir[name]]&#10;&#9;&#9;&#9;}).select ({ | pair |&#10;&#9;&#9;&#9;&#9;pair [1].notNil;&#10;&#9;&#9;&#9;});&#10;&#9;&#9;&#9;// arg target, outbus = 0, fadeTime = 0.02, addAction=\\addToHead, args;&#10;&#9;&#9;&#9;// Ensure removal from lib on end:&#10;&#9;&#9;&#9;synth = Registry (envir, \\synths, name, {&#10;&#9;&#9;&#9;&#9;this.play (&#10;&#9;&#9;&#9;&#9;&#9;~target.asTarget, ~outbus ? 0, ~fadeTime ? 0.02,&#10;&#9;&#9;&#9;&#9;&#9;~addAction ? \\addToHead, (args ? []).flat&#10;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;&#9;});&#10;&#9;&#9;&#9;synth.onStart (this, {| myself |&#10;&#9;&#9;&#9;&#9;// &#34;now adding the notifiers for updates, just on time&#34;.postln;&#10;&#9;&#9;&#9;&#9;argNames do: { | param |&#10;&#9;&#9;&#9;&#9;&#9;synth.addNotifier (envir, param, { | val |&#10;&#9;&#9;&#9;&#9;&#9;&#9;synth.set (param, val);&#10;&#9;&#9;&#9;&#9;&#9;});&#10;&#9;&#9;&#9;&#9;};&#10;&#9;&#9;&#9;});&#10;&#9;&#9;&#9;if (argNames.size == 0) {&#10;&#9;&#9;&#9;&#9;synth.onEnd (this, { synth.objectClosed;}); // in case no func args&#10;&#9;&#9;&#9;}&#10;&#9;&#9;};&#10;&#9;&#9;^synth;&#10;&#9;}&#10;} Drafts for next version See https://github.com/iani/sc-hacks/blob/master/LabCode/rebuildFunctionEplay.scd for draft to get started on this TODO.","categories":[{"name":"methods","slug":"methods","permalink":"http://iani.github.io/categories/methods/"},{"name":"notes","slug":"methods/notes","permalink":"http://iani.github.io/categories/methods/notes/"}],"tags":[{"name":"design","slug":"design","permalink":"http://iani.github.io/tags/design/"},{"name":"synth","slug":"synth","permalink":"http://iani.github.io/tags/synth/"},{"name":"TODO","slug":"TODO","permalink":"http://iani.github.io/tags/TODO/"}]},{"title":"Event eplay: Patterns updating current environment","slug":"EventEplay","date":"2017-06-11T17:54:01.000Z","updated":"2017-06-11T17:56:58.000Z","comments":true,"path":"2017/06/11/EventEplay/","link":"","permalink":"http://iani.github.io/2017/06/11/EventEplay/","excerpt":"anEnvironment.eplay(envir) Play an event as EventPattern, updating the values in envir from each event. Use custom event type: envEvent. This only updates the values in the environment. The sound must be generated by Function:eplay. See examples below.","text":"anEnvironment.eplay(envir) Play an event as EventPattern, updating the values in envir from each event. Use custom event type: envEvent. This only updates the values in the environment. The sound must be generated by Function:eplay. See examples below. Play the receiver Event in the environment given in argument envir using a custom event type to just set the values of corresponding variables at each event. For example, playing () set ~freq to 60.midicps every 1 second. (dur: 0.1).eplay; ().eplay; () eplay: \\newEnvir; Examples Example 1: Single synth, pattern, gui update (degree: Pbrown (0, 30, 2, inf), dur: 0.1).eplay;&#10;{ | freq = 400 | SinOsc.ar (freq, 0, 0.1 )}.eplay;&#10;\\window.vlayout (CSlider (\\freq)).front; Example 2: Envelope gate on-off To test triggering of envelopes, instead of writing this: { | freq = 400, gate = 0 |&#10;&#9;var env;&#10;&#9;env = Env.adsr ();&#10;&#9;SinOsc.ar (freq, 0, 0.1)&#10;&#9;* EnvGen.kr (env, gate: gate, doneAction: 0)&#10;}.eplay;&#10;//:&#10;{&#10;&#9;inf do: { | i |&#10;&#9;&#9;~gate = i % 2;&#10;&#9;0.1.rrand (0.5).wait&#10;&#9;}&#10;}.rout; one may write this: { | freq = 400, gate = 0 |&#10;&#9;var env;&#10;&#9;env = Env.adsr (0.01, 0.01, 0.9, 0.3);&#10;&#9;SinOsc.ar (freq, 0, 0.1)&#10;&#9;* EnvGen.kr (env, gate: gate, doneAction: 0)&#10;}.eplay;&#10;&#10;(dur: Pwhite (0.01, 0.15, inf), gate: Pseq([0, 1], inf)).eplay;&#10;//: Note the overlap with the still playing note in the freq change:&#10;(dur: 0.15, gate: Pseq([0, 1], inf), degree: Pstutter (4, Pbrown (-5, 20, 5, inf))).eplay; Example 3: Many patterns + many synths in same environment { | freq = 400 | SinOsc.ar (freq * [1, 1.25], 0, 0.1) }.eplay;&#10;(dur: 0.1, degree: Pbrown (-1, 20, 2, inf)).eplay;&#10;//: Start the next synth later:&#10;{ | freq = 400 |&#10;&#9;Ringz.ar (PinkNoise.ar, freq * 1.2)&#10;}.eplay (\\synth2);&#10;//: Test fade out when releasing synth to replace with new one:&#10;~fadeTime = 5;&#10;//:&#10;{ | freq = 400, ringTime = 3 |&#10;&#9;Ringz.ar (PinkNoise.ar, freq * [2, 1.2], ringTime)&#10;}.eplay (\\synth2);&#10;//:&#10;~ringTime = 0.03;&#10;//:&#10;~ringTime = 2;&#10;//: Start a new pattern in place of the old one:&#10;(dur: 0.1, degree: Pbrown (-1, 20, 2, inf), ringTime: Pwhite (0.01, 1.2, inf)).eplay;&#10;//: remove the ringTime from the next version of the pattern:&#10;(dur: 0.1, degree: Pbrown (-1, 20, 2, inf)).eplay;&#10;//: add a new pattern on the same environment, playing ringTime:&#10;(dur: 0.01, ringTime: Pbrown (0.001, 0.01, 0.01, inf)).eplay (\\ringTime);&#10;//: add a new pattern on the same environment, playing ringTime:&#10;(dur: 0.1, ringTime: Pwhite (0.01, 4, inf)).eplay (\\ringTime);&#10;//:","categories":[{"name":"methods","slug":"methods","permalink":"http://iani.github.io/categories/methods/"}],"tags":[{"name":"notification","slug":"notification","permalink":"http://iani.github.io/tags/notification/"},{"name":"EnvGen","slug":"EnvGen","permalink":"http://iani.github.io/tags/EnvGen/"},{"name":"trigger","slug":"trigger","permalink":"http://iani.github.io/tags/trigger/"},{"name":"EventPattern","slug":"EventPattern","permalink":"http://iani.github.io/tags/EventPattern/"},{"name":"Event","slug":"Event","permalink":"http://iani.github.io/tags/Event/"}]},{"title":"Triggering EnvGen","slug":"TriggeringEnvGen","date":"2017-06-11T09:36:44.000Z","updated":"2017-06-11T09:57:27.000Z","comments":true,"path":"2017/06/11/TriggeringEnvGen/","link":"","permalink":"http://iani.github.io/2017/06/11/TriggeringEnvGen/","excerpt":"With doneAction: 0 ? How is Gate congrol value used to release and then re-trigger? Example","text":"With doneAction: 0 ? How is Gate congrol value used to release and then re-trigger? Example //:&#10;&#10;{ | freq = 400, gate = 0 |&#10;&#9;var env;&#10;&#9;env = Env.adsr ();&#10;&#9;SinOsc.ar (freq, 0, 0.1)&#10;&#9;* EnvGen.kr (env, gate: gate, doneAction: 0)&#10;}.eplay;&#10;&#10;&#10;//:&#10;~gate = 1;&#10;//:&#10;~gate = 0;&#10;//:&#10;{&#10;&#9;inf do: { | i |&#10;&#9;&#9;~gate = i % 2;&#10;&#9;&#9;~freq = 300 rrand: 3000;&#10;&#9;&#9;0.9.rand.wait;&#10;&#9;}&#10;}.rout;&#10;//:&#10;{&#10;&#9;inf do: { | i |&#10;&#9;&#9;~gate = i % 2;&#10;&#9;&#9;if (~gate != 0) { ~freq = (70..90).choose.midicps};&#10;&#9;&#9;0.25.rrand (1).wait;&#10;&#9;}&#10;}.rout;&#10;//:&#10;{&#10;&#9;inf do: { | i |&#10;&#9;&#9;~gate = i % 2;&#10;&#9;&#9;if (~gate != 0) { ~freq = 300 rrand: 3000};&#10;&#9;&#9;0.01.rrand (0.1).wait;&#10;&#9;}&#10;}.rout;&#10;//:","categories":[{"name":"design","slug":"design","permalink":"http://iani.github.io/categories/design/"}],"tags":[{"name":"trigger","slug":"trigger","permalink":"http://iani.github.io/tags/trigger/"},{"name":"design","slug":"design","permalink":"http://iani.github.io/tags/design/"},{"name":"envgen","slug":"envgen","permalink":"http://iani.github.io/tags/envgen/"},{"name":"env","slug":"env","permalink":"http://iani.github.io/tags/env/"},{"name":"gate","slug":"gate","permalink":"http://iani.github.io/tags/gate/"}]},{"title":"Nevent: Environment that notifes variable updates","slug":"Nevent","date":"2017-06-11T09:17:57.000Z","updated":"2017-06-11T09:17:57.000Z","comments":true,"path":"2017/06/11/Nevent/","link":"","permalink":"http://iani.github.io/2017/06/11/Nevent/","excerpt":"","text":"Nevent is an EnvironmentRedirect that notifies the changes of value of its variables.","categories":[{"name":"classes","slug":"classes","permalink":"http://iani.github.io/categories/classes/"}],"tags":[{"name":"notification","slug":"notification","permalink":"http://iani.github.io/tags/notification/"}]},{"title":"Store Specs and SynthDefs in Library","slug":"StoreSpecsAndSynthDefsInLibrary","date":"2017-06-09T09:06:09.000Z","updated":"2017-06-09T09:10:00.000Z","comments":true,"path":"2017/06/09/StoreSpecsAndSynthDefsInLibrary/","link":"","permalink":"http://iani.github.io/2017/06/09/StoreSpecsAndSynthDefsInLibrary/","excerpt":"","text":"Specs and SynthDefs should be stored in Library using Registry. Advantages: simplify and unify the API for accessing Specs and SynthDefs (and SynthDescs). provide global access to Specs and SynthDefs for all environments, guis, synths using spec/synthdef name. ensure SynthDefs are always loaded when the server is rebooted, also when it is a remote server. provide easy global access to SynthDescs for automatic GUI generation.","categories":[{"name":"notes","slug":"notes","permalink":"http://iani.github.io/categories/notes/"}],"tags":[{"name":"design","slug":"design","permalink":"http://iani.github.io/tags/design/"},{"name":"TODO","slug":"TODO","permalink":"http://iani.github.io/tags/TODO/"}]},{"title":"Function:eplay : play a function and follow its arguments from an environment","slug":"Function-eplay","date":"2017-06-08T15:46:28.000Z","updated":"2017-06-08T15:59:12.000Z","comments":true,"path":"2017/06/08/Function-eplay/","link":"","permalink":"http://iani.github.io/2017/06/08/Function-eplay/","excerpt":"Provide arguments for playing a function from values found in an environment. connect all control names in the function's arguments to an environment for auto-update Free all notifications from the synth when it stops playing.","text":"Provide arguments for playing a function from values found in an environment. connect all control names in the function's arguments to an environment for auto-update Free all notifications from the synth when it stops playing. Method code + Function {&#10;&#9;eplay { | envir = \\envir |&#10;&#9;&#9;var synth;&#10;&#9;&#9;envir = envir.asEnvironment;&#10;&#9;&#9;envir use: {&#10;&#9;&#9;&#9;var argNames, args;&#10;&#9;&#9;&#9;argNames = this.def.argNames;&#10;&#9;&#9;&#9;args = argNames.collect ({ | name |&#10;&#9;&#9;&#9;&#9;[name, currentEnvironment [name]]&#10;&#9;&#9;&#9;}).select ({ | pair |&#10;&#9;&#9;&#9;&#9;pair [1].notNil;&#10;&#9;&#9;&#9;}).flat;&#10;&#9;&#9;&#9;// arg target, outbus = 0, fadeTime = 0.02, addAction=\\addToHead, args;&#10;&#9;&#9;&#9;synth = this.play (&#10;&#9;&#9;&#9;&#9;~target.asTarget, ~outbus ? 0, ~fadeTime ? 0.02,&#10;&#9;&#9;&#9;&#9;~addAction ? \\addToHead, args&#10;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;argNames do: { | param |&#10;&#9;&#9;&#9;&#9;synth.addNotifier (envir, param, { | val |&#10;&#9;&#9;&#9;&#9;&#9;synth.set (param, val);&#10;&#9;&#9;&#9;&#9;});&#10;&#9;&#9;&#9;};&#10;&#9;&#9;};&#10;&#9;&#9;// This is done by addNotifier anyway:&#10;&#9;&#9;// synth.onEnd (this, { synth.objectClosed });&#10;&#9;&#9;^synth;&#10;&#9;}&#10;} Example \\window.vlayout (&#10;&#9;HLayout (&#10;&#9;&#9;StaticText ().string_ (\\freq),&#10;&#9;&#9;Slider.horizontal.connectEnvir (\\freq),&#10;&#9;&#9;NumberBox ().connectEnvir (\\freq)&#10;&#9;)&#10;).front;&#10;//:&#10;{&#10;&#9;loop {&#10;&#9;&#9;~freq = 400 + 400.rand;&#10;&#9; 1.wait;&#10;&#9;}&#10;}.fork;&#10;//:&#10;{ | freq = 440 | SinOsc.ar (freq, 0, 0.1) }.eplay;&#10;//:","categories":[{"name":"methods","slug":"methods","permalink":"http://iani.github.io/categories/methods/"}],"tags":[{"name":"synth","slug":"synth","permalink":"http://iani.github.io/tags/synth/"},{"name":"method","slug":"method","permalink":"http://iani.github.io/tags/method/"},{"name":"environment","slug":"environment","permalink":"http://iani.github.io/tags/environment/"}]},{"title":"Building GUIs","slug":"BuildingGUIs","date":"2017-06-06T11:18:21.000Z","updated":"2017-06-06T14:24:35.000Z","comments":true,"path":"2017/06/06/BuildingGUIs/","link":"","permalink":"http://iani.github.io/2017/06/06/BuildingGUIs/","excerpt":"This notebook shows how to build GUIs starting from scratch, with minimal code and in small steps.","text":"This notebook shows how to build GUIs starting from scratch, with minimal code and in small steps. Just a window //: 1 Just a window&#10;Window (&#34;window name&#34;).front; Add a slider and resize. Use VLayout for automatic resizing. Window (&#34;window name&#34;)&#10;.view.layout_ (&#10;&#9;VLayout (&#10;&#9;&#9;Slider ()&#10;&#9;)&#10;).front;&#10;//: Make the slider horizontal.&#10;Window (&#34;window name&#34;)&#10;.view.layout_ (&#10;&#9;VLayout (&#10;&#9;&#9;Slider ()&#10;&#9;&#9;.orientation_ (\\horizontal)&#10;&#9;)&#10;).front; Add more sliders Use a function to avoid repeating spec code! Make the orientation an argument to enable customization. var makeSlider;&#10;&#10;makeSlider = { | orientation = \\horizontal |&#10;&#9;Slider ()&#10;&#9;&#9;.orientation_ (orientation)&#10;};&#10;&#10;Window (&#34;window name&#34;)&#10;.view.layout_ (&#10;&#9;VLayout (&#10;&#9;&#9;*({makeSlider.([\\horizontal, \\vertical].choose)} ! 10)&#10;&#9;)&#10;).front; Add more arguments for controlSpec, label, and action var makeSlider;&#10;&#10;makeSlider = { | label = &#34;slider&#34;, min = 0, max = 10, step = 0, default = 0.5, orientation = \\horizontal,&#10;&#9;action |&#10;&#9;var controlSpec;&#10;&#9;controlSpec = [min, max, \\lin, step, default].asSpec;&#10;&#9;// provide default action if needed:&#10;&#9;action ?? {&#10;&#9;&#9;action = { | value | controlSpec.map (value).postln }&#10;&#9;};&#10;&#9;HLayout (&#10;&#9;&#9;StaticText ().string_ (label),&#10;&#9;&#9;Slider ()&#10;&#9;&#9;.action_ ({ | me | action.(me.value)})&#10;&#9;&#9;.orientation_ (orientation)&#10;&#9;)&#10;};&#10;&#10;Window (&#34;window name&#34;)&#10;.view.layout_ (&#10;&#9;VLayout (&#10;&#9;&#9;*({makeSlider.([\\horizontal, \\vertical].choose)} ! 10)&#10;&#9;)&#10;).front; Add number box, after the slider. var makeSlider;&#10;&#10;makeSlider = { | label = &#34;slider&#34;, min = 0, max = 10, step = 0, default = 0.5, orientation = \\horizontal,&#10;&#9;action |&#10;&#9;var controlSpec;&#10;&#9;controlSpec = [min, max, \\lin, step, default].asSpec;&#10;&#9;// provide default action if needed:&#10;&#9;action ?? {&#10;&#9;&#9;action = { | value | controlSpec.map (value).postln }&#10;&#9;};&#10;&#9;HLayout (&#10;&#9;&#9;StaticText ().string_ (label),&#10;&#9;&#9;Slider ()&#10;&#9;&#9;.action_ ({ | me | action.(me.value)})&#10;&#9;&#9;.orientation_ (orientation),&#10;&#9;&#9;NumberBox ())&#10;};&#10;&#10;Window (&#34;window name&#34;)&#10;.view.layout_ (&#10;&#9;VLayout (&#10;&#9;&#9;*({makeSlider.(&#10;&#9;&#9;&#9;max: 0.0.rrand (20.0),&#10;&#9;&#9;&#9;orientation: [\\horizontal, \\vertical].choose)} ! 10)&#10;&#9;)&#10;).front; Add value update for number box and slider var makeSlider; makeSlider = { | label = \"slider\", min = 0, max = 10, step = 0, default = 0.5, orientation = \\horizontal, action | var controlSpec, mappedVal, slider, numberBox; controlSpec = [min, max, \\lin, step, default].asSpec; // provide default action if needed: action ?? { action = { | value | value.postln } }; HLayout ( StaticText ().string_ (label), slider = Slider () .action_ ({ | me | mappedVal = controlSpec.map (me.value); numberBox.value = mappedVal; action.(mappedVal)}) .orientation_ (orientation), numberBox = NumberBox () .action_ ({ | me | mappedVal = me.value; slider.value = controlSpec.unmap (mappedVal); action.(mappedVal) }) ) }; Window (\"window name\") .view.layout_ ( VLayout ( *({ | i | makeSlider.(format (\"slider %\", i), max: 0.0.rrand (20.0), orientation: [\\horizontal, \\vertical].choose) } ! 10) ) ).front; Group the controlSpec arguments to make them more compact Also initialize the values of gui elements #+BEGIN_SRC sclang var makeSlider; makeSlider = { | label = \"slider\", controlSpec, orientation = \\horizontal, action | var mappedVal, slider, numberBox; // convert controlSpec arg into ControlSpec controlSpec = (controlSpec ? []).asSpec; // provide default action if needed: action ?? { action = { | value | value.postln } }; HLayout ( StaticText ().string_ (label), slider = Slider () .action_ ({ | me | mappedVal = controlSpec.map (me.value); numberBox.value = mappedVal; action.(mappedVal)}) .orientation_ (orientation) .value_ (controlSpec unmap: controlSpec.default), numberBox = NumberBox () .action_ ({ | me | mappedVal = me.value; slider.value = controlSpec.unmap (mappedVal); action.(mappedVal) }) .value_ (controlSpec.default) ) }; Window (\"window name\") .view.layout_ ( VLayout ( *([\\freq, &amp;] collect: { | name | makeSlider.(format (\" %\", name), controlSpec: name, orientation: \\horizontal * [\\horizontal, \\vertical].choose * ) }) ) ).front; How to add all available options for Slider and NumberBox, eg. floating point digits etc? Instead of adding more arguments, move to the next step: Define a class and provide the options as defaults. Next steps &#x2026; Control a routine from a GUI. Let the GUI elements set environment variables of an environment. Let the routine run within this environment to have access to its variables. Save the current settings on file. Reload settings from file. Do similar things as with 1, but with a synth instead of a routine. Do similar things as with 1, but with an EventPattern instead of a routine.","categories":[{"name":"gui","slug":"gui","permalink":"http://iani.github.io/categories/gui/"}],"tags":[{"name":"learning","slug":"learning","permalink":"http://iani.github.io/tags/learning/"},{"name":"gui","slug":"gui","permalink":"http://iani.github.io/tags/gui/"}]},{"title":"EventStream: Modify Patterns while playing","slug":"EventStream","date":"2017-06-05T15:42:37.000Z","updated":"2017-06-06T08:20:38.000Z","comments":true,"path":"2017/06/05/EventStream/","link":"","permalink":"http://iani.github.io/2017/06/05/EventStream/","excerpt":"An EventStream makes it easy to modify patterns while playing them.","text":"An EventStream makes it easy to modify patterns while playing them. How it works An EventPattern creates EventStreams which are played by EventStreamPlayer. EventStream stores an event whose values are streams and uses this to produce a new event which is played by EventStreamPlayer. It is thus possible to modify the event stored in the EventStream while the EventStreamPlayer is playing it. This makes it easy to modify a playing pattern (which is difficult when using Pbind). Example () +&gt; \\e; 0.1 +&gt;.dur \\e; Pseq ((0..20), inf) +&gt;.degree \\e; Prand ((0..20), inf) +&gt;.degree \\e; (freq: Pfunc ({ 300 rrand: 1000 }), dur: Prand ([0.1, 0.2], inf)) +&gt; \\e; (freq: Pfunc ({ 30.rrand(80).midicps }), dur: Pfunc ({ 0.1 exprand: 1 }), legato: Prand ([0.1, 2], inf)) +&gt; \\e; (degree: Pseq ((0..20), inf), dur: 0.1) +!&gt;.degree \\e; Note: +&gt; adds all key-value pairs of an event to the event being played. +!&gt; replaces the contents of the event being played by the contents of the new event.","categories":[{"name":"classes","slug":"classes","permalink":"http://iani.github.io/categories/classes/"}],"tags":[{"name":"EventPattern","slug":"EventPattern","permalink":"http://iani.github.io/tags/EventPattern/"},{"name":"EventStream","slug":"EventStream","permalink":"http://iani.github.io/tags/EventStream/"},{"name":"EventStreamPlayer","slug":"EventStreamPlayer","permalink":"http://iani.github.io/tags/EventStreamPlayer/"}]},{"title":"Notification: Register a function callback to a message and a pair of objects","slug":"Notification","date":"2017-06-05T15:42:21.000Z","updated":"2017-06-08T15:58:26.000Z","comments":true,"path":"2017/06/05/Notification/","link":"","permalink":"http://iani.github.io/2017/06/05/Notification/","excerpt":"Notification is an improved version of the NotificationCenter class. This class enables objects to register a function which is called when another object changes according to some aspect. The aspect is expressed by a symbol. To trigger a notification action, one sends the message changed to an object together with a symbol expressing the aspect which changed. The function will only be evaluated for those objects which have registered to listen to the changing object according to the given aspect symbol. This allows detailed control of callback execution amongst objects of the system. For example, one can tell a gui object to change its color to green when a synth starts, and to change its color to red when that synth stops.","text":"Notification is an improved version of the NotificationCenter class. This class enables objects to register a function which is called when another object changes according to some aspect. The aspect is expressed by a symbol. To trigger a notification action, one sends the message changed to an object together with a symbol expressing the aspect which changed. The function will only be evaluated for those objects which have registered to listen to the changing object according to the given aspect symbol. This allows detailed control of callback execution amongst objects of the system. For example, one can tell a gui object to change its color to green when a synth starts, and to change its color to red when that synth stops. Notification adds the following enhancements: Ability to remove existing notification connections reliably. Several methods for easily adding or modifying connections between objects. Ability to remove all connections from an object with a single message, objectClosed, and also to execute additional actions when that object closes. Closing here means that the object is freed and will no longer be used by the system. Examples onObjectClosed Registry uses onObjectClosed to remove objects by sending them that message: *new { | ... pathAndFunc |&#10;&#9; var path, makeFunc, instance;&#10;&#9; makeFunc = pathAndFunc.last;&#10;&#9; path = pathAndFunc[0..pathAndFunc.size-2];&#10;&#9; instance = Library.global.atPath(path);&#10;&#9; if (instance.isNil) {&#10;&#9;&#9; instance = makeFunc.value;&#10;&#9;&#9; Library.global.putAtPath(path, instance);&#10;&#9;&#9; instance.onObjectClosed(this, {&#10;&#9;&#9;&#9; this.remove(*path)&#10;&#9;&#9; });&#10;&#9; };&#10;&#9; ^instance;&#10;} This is in turn used by oscFunc and rout methods for removing OSCFunc and Routine objects in order to replace them with new instances. addNotifierOneShot The addNotifierOneShot method executes the registered Function just once. This is useful when it is clear that only one call is required. For example, the onEnd and onStart methods for Node make use of the addNotifierOneShot method: + Node {&#10;&#9;onStart { | listener, action |&#10;&#9;&#9;NodeWatcher.register(this);&#10;&#9;&#9;listener.addNotifierOneShot(this, \\n_go, action);&#10;&#9;}&#10;&#10;&#9;onEnd { | listener, action |&#10;&#9;&#9;NodeWatcher.register(this);&#10;&#9;&#9;// this.isPlaying = true; // dangerous&#10;&#9;&#9;listener.addNotifierOneShot(this, \\n_end, action);&#10;&#9;}&#10;} Similar extensions can be built for whatever object needs to monitor the closing or end of an object such as closing of a Window or stopping of a Pattern.","categories":[{"name":"classes","slug":"classes","permalink":"http://iani.github.io/categories/classes/"}],"tags":[{"name":"Notification","slug":"Notification","permalink":"http://iani.github.io/tags/Notification/"}]},{"title":"Registry: Hierarchical Namespaces","slug":"Registry","date":"2017-06-05T15:41:22.000Z","updated":"2017-06-05T17:15:07.000Z","comments":true,"path":"2017/06/05/Registry/","link":"","permalink":"http://iani.github.io/2017/06/05/Registry/","excerpt":"This class helps to store objects and to retrieve them using a key. This is similar to the way that with classes such as Pdef, Ndef, OSCdef work, but Registry can be used to add the same feature ot any class, without subclassing it. To create this behavior instead, add a method to Symbol for accessing the kind of object needed. For example: \\aSymbol.oscFunc. This also allows easier customization of how the object is created if not found.","text":"This class helps to store objects and to retrieve them using a key. This is similar to the way that with classes such as Pdef, Ndef, OSCdef work, but Registry can be used to add the same feature ot any class, without subclassing it. To create this behavior instead, add a method to Symbol for accessing the kind of object needed. For example: \\aSymbol.oscFunc. This also allows easier customization of how the object is created if not found. How it works Store an object in Library under an array of objects (called a path). When accessing the path, create the object if not already stored, else return the previously stored object. Example This is the code that makes it possible to create or modify an OSCFunc bound to a symbol. It defines the methods Function:oscFunc and Symbol:removeOsc. + Function {&#10;&#9;oscFunc { | path |&#10;&#9;&#9;path.removeOsc;&#10;&#9;&#9;^Registry (&#39;oscFuncs&#39;, path, { OSCFunc (this, path) });&#10;&#9;}&#10;}&#10;&#10;+ Symbol {&#10;&#9;removeOsc {&#10;&#9;&#9;Registry.doIfFound (&#39;oscFuncs&#39;, this, { | found |&#10;&#9;&#9;&#9;found.objectClosed;&#10;&#9;&#9;&#9;found.free;&#10;&#9;&#9;}); &#10;&#9;}&#10;}","categories":[{"name":"classes","slug":"classes","permalink":"http://iani.github.io/categories/classes/"}],"tags":[{"name":"registry","slug":"registry","permalink":"http://iani.github.io/tags/registry/"}]}]}