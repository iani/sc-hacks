{"meta":{"title":"SC Hacks","subtitle":"SC code step-by-step","description":"Gradually introducing recipes from previous SuperCollider libraries","author":"Iannis Zannos","url":"http://iani.github.io"},"pages":[{"title":"About sc-hacks","date":"2017-06-04T15:29:22.000Z","updated":"2017-06-04T15:45:29.000Z","comments":true,"path":"about/index.html","permalink":"http://iani.github.io/about/index.html","excerpt":"","text":"In this repository, I will review the techniques developed in my libraries for SuperCollider tiny-sc and tiny-inc. I will try to build a cleaner structure step-by-step, and reducing the code to essential features, as far as possible."}],"posts":[{"title":"Registry: Hierarchical Namespaces","slug":"Registry","date":"2017-06-05T05:43:33.000Z","updated":"2017-06-05T05:43:33.000Z","comments":true,"path":"2017/06/05/Registry/","link":"","permalink":"http://iani.github.io/2017/06/05/Registry/","excerpt":"","text":"Registry class What it is for This class make its possible to store objects and retrieve them, as done with classes such as Pdef, Ndef, OSCdef etc, but without having to subclass. To create this behavior instead, add a method to Symbol for accessing the kind of object needed. For example: \\aSymbol.oscFunc. This also allows easier customization of how the object is created if not found. How it works Store an object in Library under an array of objects (called a path). When accessing the path, create the object if not already stored, else return the previously stored object. Example This is the code that makes it possible to create or modify an OSCFunc bound to a symbol. It defines the methods Function:oscFunc and Symbol:removeOsc. + Function {&#10;&#9;oscFunc { | path |&#10;&#9;&#9;path.removeOsc;&#10;&#9;&#9;^Registry ('oscFuncs', path, { OSCFunc (this, path) });&#10;&#9;}&#10;}&#10;&#10;+ Symbol {&#10;&#9;removeOsc {&#10;&#9;&#9;Registry.doIfFound ('oscFuncs', this, { | found |q&#10;&#9;&#9;&#9;found.objectClosed;&#10;&#9;&#9;&#9;found.free;&#10;&#9;&#9;}); &#10;&#9;}&#10;}","categories":[{"name":"classes","slug":"classes","permalink":"http://iani.github.io/categories/classes/"}],"tags":[{"name":"registry","slug":"registry","permalink":"http://iani.github.io/tags/registry/"}]},{"title":"EventStream: Modify Patterns while playing","slug":"EventStream","date":"2017-06-05T04:54:50.000Z","updated":"2017-06-05T05:31:14.000Z","comments":true,"path":"2017/06/05/EventStream/","link":"","permalink":"http://iani.github.io/2017/06/05/EventStream/","excerpt":"","text":"What it does An EventStream makes it possible to modify patterns while playing them. How it works An EventPattern creates EventStreams which are played by EventStreamPlayer. EventStream stores an event whose values are streams and uses this to produce a new event which is played by EventStreamPlayer. It is thus possible to modify the event stored in the EventStream while the EventStreamPlayer is playing it. This makes it easy to modify a playing pattern (which is difficult when using Pbind). Example () +&gt; \\e; 0.1 +&gt;.dur \\e; Pseq ((0..20), inf) +&gt;.degree \\e; Prand ((0..20), inf) +&gt;.degree \\e; (freq: Pfunc ({ 300 rrand: 1000 }), dur: Prand ([0.1, 0.2], inf)) +&gt; \\e; (freq: Pfunc ({ 30.rrand(80).midicps }), dur: Pfunc ({ 0.1 exprand: 1 }), legato: Prand ([0.1, 2], inf)) +&gt; \\e; (degree: Pseq ((0..20), inf), dur: 0.1) +!&gt;.degree \\e; Note: +&gt; adds all key-value pairs of an event to the event being played. +!&gt; replaces the contents of the event being played by the contents of the new event.","categories":[{"name":"classes","slug":"classes","permalink":"http://iani.github.io/categories/classes/"}],"tags":[{"name":"EventStream","slug":"EventStream","permalink":"http://iani.github.io/tags/EventStream/"},{"name":"EventPattern","slug":"EventPattern","permalink":"http://iani.github.io/tags/EventPattern/"},{"name":"EventStreamPlayer","slug":"EventStreamPlayer","permalink":"http://iani.github.io/tags/EventStreamPlayer/"}]},{"title":"Notification: Register a function callback to a message and a pair of objects","slug":"Notification","date":"2017-06-04T19:29:46.000Z","updated":"2017-06-05T04:05:59.000Z","comments":true,"path":"2017/06/04/Notification/","link":"","permalink":"http://iani.github.io/2017/06/04/Notification/","excerpt":"","text":"Notification class What it is for Notification is an improved version of the NotificationCenter class. This class enables objects to register a function which is called when another object changes according to some aspect. The aspect is expressed by a symbol. To trigger a notification action, one sends the message changed to an object together with a symbol expressing the aspect which changed. The function will only be evaluated for those objects which have registered to listen to the changing object according to the given aspect symbol. This allows detailed control of callback execution amongst objects of the system. For example, one can tell a gui object to change its color to green when a synth starts, and to change its color to red when that synth stops. Notification adds the following enhancements: Ability to remove existing notification connections reliably. Several methods for easily adding or modifying connections between objects. Ability to remove all connections from an object with a single message, objectClosed, and also to execute additional actions when that object closes. Closing here means that the object is freed and will no longer be used by the system. Examples onObjectClosed Registry uses onObjectClosed to remove objects by sending them that message: *new { | ... pathAndFunc |&#10;&#9; var path, makeFunc, instance;&#10;&#9; makeFunc = pathAndFunc.last;&#10;&#9; path = pathAndFunc[0..pathAndFunc.size-2];&#10;&#9; instance = Library.global.atPath(path);&#10;&#9; if (instance.isNil) {&#10;&#9;&#9; instance = makeFunc.value;&#10;&#9;&#9; Library.global.putAtPath(path, instance);&#10;&#9;&#9; instance.onObjectClosed(this, {&#10;&#9;&#9;&#9; this.remove(*path)&#10;&#9;&#9; });&#10;&#9; };&#10;&#9; ^instance;&#10;} This is in turn used by oscFunc and rout methods for removing OSCFunc and Routine objects in order to replace them with new instances. addNotifierOneShot The addNotifierOneShot method executes the registered Function just once. This is useful when it is clear that only one call is required. For example, the onEnd and onStart methods for Node make use of the addNotifierOneShot method: + Node {&#10;&#9;onStart { | listener, action |&#10;&#9;&#9;NodeWatcher.register(this);&#10;&#9;&#9;listener.addNotifierOneShot(this, \\n_go, action);&#10;&#9;}&#10;&#10;&#9;onEnd { | listener, action |&#10;&#9;&#9;NodeWatcher.register(this);&#10;&#9;&#9;// this.isPlaying = true; // dangerous&#10;&#9;&#9;listener.addNotifierOneShot(this, \\n_end, action);&#10;&#9;}&#10;} Similar extensions can be built for whatever object needs to monitor the closing or end of an object such as closing of a Window or stopping of a Pattern.","categories":[{"name":"classes","slug":"classes","permalink":"http://iani.github.io/categories/classes/"}],"tags":[{"name":"Notification","slug":"Notification","permalink":"http://iani.github.io/tags/Notification/"}]}]}