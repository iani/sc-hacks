ROADMAP  6 Sep 2017 14:19

* Operator TODOs
  :PROPERTIES:
  :DATE:     <2017-10-05 Thu 18:04>
  :END:

** Operator Design Draft

Examples of 4 operator types in sc-hacks

#+BEGIN_SRC javascript
// type 1: +>
{ WhiteNoise.ar(0.1) } +> \test; // 1. function +>player
(dur: 0.1, degree: Pwhite(1, 10)) +> \test; // 2. event +> player
\default +> \test; // SynthDef name +> player
// type 2: <+
\freq <+ { LFNoise0.kr(5).range(500, 1500) }; // 1. parameter <+ Function
\amp <+ Env.perc; // parameter <+ Envelope
// type 3: *>
\source *> \effect // source player *> effect player
(freq: Pbrown(50, 90, 5), dur: 0.1) *> \effect; // 2. event *> player's environment
// type 4: <*
\test <* \hihat; // 1. parameter <* buffer name
#+END_SRC

As basic operators, /sc-hacks/ uses four combinations built from + and * with > and <.  They are in two groups (=+=-Group and =*=-Group):

1. *+-Group* : =+>=, =<+=.  *+>* plays the receiver (left argument) object in the player whose name is named by the left argument.  *<+* plays the left argument object in the parameter whose name is named by the receiver.
2. **-Group* : =*>, =<*=. The operators of the =*= group have parallel usage principles as that of the =+= group, but they interpret the same kinds of receiver in different ways, to provide additional functionality.

In some more detail:

1. =+>= : Play the receiver in the Player named by the argument. 3 types of receivers can be used: 1. *Function:* Play as synth function into the Player named by the argument. 2. *Event:* Play as pattern (via EventStreamPlayer) into the Player named by the argument. 3. *Symbol:* Play as synth using the Receiver Symbol as name of the Synth to be player.
2. =<+= : Use the argument as input to the environment variable named by the receiver (in the current environment). Several different types of argument are possible: Function, SimpleNumber (Integer, Float), MIDI and OSC-function templates (custom classes in this library), GUI type objects, Symbol (names of buffers or of players).
3. =*>= : The =*>= operator functions like the =+>= operator in that it plays the receiver in the player named by the argument, but it interprets the types of the receiver in a different way: *Functions* get played as routines in the environment of the player.  *Events* get played as patterns, but using a custom type which instead of playing sounds with =play= event type, just set the environment variables of the environment of the player named by the receiver, with the values produced by each key in the event. A *Symbol* as receiver indicates to connect the output of the player named by the receiver to the input of the player named by the argument.
4. =<*= This operator is used to send the bufnum of buffers to parameters.

Here is a tabular overview of operator actions associated to different types of receiver and argument:

|------+------------+------------+------------+--------------------------------------|
| *no* | *receiver* | *operator* | *argument* | *action*                             |
|------+------------+------------+------------+--------------------------------------|
|    1 | Symbol     | =+>=       | Symbol     | Play Synthdef                        |
|    2 | Symbol     | =*>=       | Symbol     | Link Players                         |
|    3 | Symbol     | =<+=       | Number     | Set parameter                        |
|    4 | Symbol     | =<+=       | Function   | Map parameter                        |
|    5 | Symbol     | =<+=       | Env        | Map parameter                        |
|    6 | Symbol     | =<*=       | Symbol     | Set bufnum                           |
|    7 | Symbol     | =<+=       | MIDI       | Bind MIDIFunc                        |
|    8 | Symbol     | =<+=       | OSC        | Bind OSCFunc                         |
|    9 | Symbol     | =<+=       | Widget     | Bind GUI Widget                      |
|   10 | Function   | =+>=       | Symbol     | Play Synth                           |
|   11 | Function   | =*>=       | Symbol     | Play Routine                         |
|   12 | Event      | =+>=       | Symbol     | Play Pattern in Player               |
|   13 | Event      | =*>=       | Symbol     | Play Pattern in Player's Environment |
|   14 | UGen       | =<+=       | Symbol     | Read input from Player's Output      |
|   15 | Symbol     | =@=        | Symbol     | Store Bus in player parameter |
#+TBLFM: $1=@-1 + 1::@2$1=1
** DONE 1. Function =+>= Symbol: Play Synth
   CLOSED: [2017-09-06 Wed 14:14]

** DONE 2. Symbol =+>= Symbol: Play Synthdef
   CLOSED: [2017-09-06 Wed 14:13]

#+BEGIN_SRC javascript
\default +> \player1; // play SynthDef named default in player named player1
#+END_SRC
** DONE 3. Event =+>= Symbol: Play Pattern in Player
   CLOSED: [2017-09-06 Wed 14:13]

** DONE 4. Symbol =*>= Symbol: Link Players
   CLOSED: [2017-09-24 Sun 06:50]

#+BEGIN_SRC javascript
\source *> \effect; // use default i/o parameters (\out, \in)
\source *>.input2 \effect; // specify custom input parameter
\source @.output2 *> \effect // specify custom output parameter
\source @.output2 *>.input2 \effect; // specify custom input and output parameter
#+END_SRC

Adverb specifies custom input parameter for the argument player.

To specify a custom output parameter for the reader player, use the =@= operator:

** DONE 5. Symbol =<+= Number: Set parameter
   CLOSED: [2017-09-27 Wed 09:12]
** DONE 6. Symbol =<+= Function: Map parameter
   CLOSED: [2017-09-27 Wed 09:13]
** DONE 7. Symbol =<+= Env: Map parameter
   CLOSED: [2017-09-27 Wed 09:13]
** DONE 8. Symbol =<+= Symbol: Set bufnum
   CLOSED: [2017-09-27 Wed 22:46]
** DONE 9. Function =*>= Symbol: Play Routine
   CLOSED: [2017-09-29 Fri 12:28]
** DONE 10. Event =*>= Symbol: Play Pattern in Player's Environment
   CLOSED: [2017-10-04 Wed 17:19]
** TODO Symbol =<+= ControlSpec: Bind ControlSpec to parameter in Environment
   :PROPERTIES:
   :DATE:     <2017-10-05 Thu 18:32>
   :END:

** TODO 7. Symbol =<+= MIDI: Bind MIDIFunc
** TODO 8. Symbol =<+= OSC: Bind OSCFunc
** TODO 9. Symbol =<+= Widget: Bind GUI Widget
** TODO 14. UGen =<+= Symbol: Read input from Player's Output

** TODO 15. Symbol =@= Symbol: Bind parameter to bus

: Bus binding operator: Store bus in parameter of player.
: Adverb indicates number of channels or environment.

#+BEGIN_SRC javascript
// create 2-channel bus for parameter \in of player \source:
\source @.2 \in;
// create 1-channel bus for parameter \in of player \source1 in environment \sourceEnvir:
\source1 @.sourceEnvir \in;
// Chain @ operator expressions to customize linked bus assignment:
\source @.envir \out2 *> (\effect @.fxenvir \in3);
#+END_SRC

In addition to the 4 operators above, /sc-hacks/ uses =@= to configure busses bound to parameters of player.  The =@= operator returns a player-parameter-bus object that can be linked to another player-parameter-bus.

* Other TODOs
  :PROPERTIES:
  :DATE:     <2017-09-06 Wed 14:20>
  :END:
** TODO Implement synchronization to next beat using TempoClock

Starting point: (from: http://doc.sccode.org/Classes/TempoClock.html#-nextTimeOnGrid)
#+BEGIN_SRC sclang

t= TempoClock.default;
t.nextTimeOnGrid(t.beatsPerBar) == t.nextBar // => true

#+END_SRC
** DONE implement release for Symbol, Player.
   CLOSED: [2017-09-24 Sun 06:50]
   :PROPERTIES:
   :DATE:     <2017-09-06 Wed 14:21>
   :END:
** DONE redo file loading scheme
   CLOSED: [2017-09-28 Thu 18:16]
   :PROPERTIES:
   :DATE:     <2017-09-27 Wed 09:30>
   :END:
** DONE redo window scheme
   CLOSED: [2017-09-28 Thu 18:16]
   :PROPERTIES:
   :DATE:     <2017-09-27 Wed 09:30>
   :END:
*** DONE attach windows to Registry(\window, name or environment)
    CLOSED: [2017-09-27 Wed 22:30]
*** review control spec adapter mechanism.
** DONE make SynthPlayer:release use ~fadeTime
   CLOSED: [2017-09-28 Thu 18:22]
   :PROPERTIES:
   :DATE:     <2017-09-06 Wed 14:20>
   :END:
** TODO Make routine snippets register with label. Stop previous one when starting same label
:PROPERTIES:
:DATE:     <2017-10-06 Fri 13:50>
:END:
** TODO Add GUI items to show what players/buffers are playing and give more details
:PROPERTIES:
:DATE:     <2017-10-06 Fri 13:50>
:END:
* Implementation notes
  :PROPERTIES:
  :DATE:     <2017-10-05 Thu 17:31>
  :END:

Here notes about considerations made during implementation.
** Use Registry to store additional Nevent data items?
   :PROPERTIES:
   :DATE:     <2017-10-05 Thu 17:33>
   :END:

Instead of adding more instance variables to Nevent, use Registry to access additional objects attached to each Nevent instance.

Currently Nevent has the following 5 instance variables:

#+BEGIN_SRC sclang
	var <name, <players, busses, <writers, routines;
#+END_SRC

Of the above, only name is required, for printing.  =players=, =busses=, =writers=, =routines= could be implemented through access methods in a similar way as outlined in method =Object:window=.  At this stage, these variables will be left as they have been coded. However several new state-items are planned, which will be implemented with methods using =Registry=:

- =spec= ControlSpecs or similar specs attached to a =Nevent= instance.
- =midi= MIDIFuncs attached to a =Nevent= instance.
- =osc= OSCFuncs attached to a =Nevent= instance.

At a later revision of the library, the 4 instance variables of =Nevent=: =players=, =busses=, =writers=, =routines= may be gradually migrated to methods using =Registry=.
* Extensions, Projects
** StartupFiles : save and recall configurations of startup files
   :PROPERTIES:
   :DATE:     <2018-07-11 Wed 18:22>
   :END:

Purpose: Instead of having a single startup file that is stored in the Users Application Support directory, permit to use multiple startup files, and have these stored in subfolders contiained in the present library's main folder. 
**  Advantages 

There are two advantages:

1. One can use multiple files to combine different tested parts of code for one application.
2. The files are found and loaded even when the library is moved to a different folder, because their path is relative to the location of the =SstartupFiles= class, which is stored inside the library. 
** Protecting user's custom files from overwriting by git repository updates

If a user edits the files in the startup folder, the edits will be overwritten when the user pulls a newer version of the library.  For this reason, =StartupFiles= looks for startup files in two folders: 

1. In =sc-hacks/Startup/= folder.
2. In User Application Support Directory/Startup folder.

The folder outside of =sc-hacks= is safe because it will not be overwritten even if the user does not use =git= but downloads the library as zipped file from github instead.
** GUI

| text input for new sc-hacks file name | text input for new user file name         |
| sc-hacks startup files list pane      | user startup files list pane              |
| list of configurations                | files selected by user for current config |
