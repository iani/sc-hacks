/*
	Learn how to write your own event types in order to extend functionality of Event playing:

	- Play polyphonically with one EventPattern, without using Ppar. 
	- Improve playing complex sound textures from Pseqs whose values are arrays of parameters
	- Improve playing legato (better version of Pmono?)
*/
//: event types are stored in: Event.parentEvents.default.eventTypes
// this is how to see the eventTypes: 
Event.parentEvents.default.eventTypes.keys.asArray.sort.asCompileString;
//: So we start creating new event types here:
Event.parentEvents.default.eventTypes [\custom1] = { | server |
	"the server is: ".post;
	server.postln;
	"the instrument is: ".post;
	~instrument.postln;
	"next trying to post ~synth ".post;
	~synth.postln;
	Synth (~instrument, [freq: ~freq.value]);
};
//:
(degree: -1, type: \custom1).play;
//:
(degree: 20).play;
//:
(degree: Prand ((10..20), inf)) +> \test;
//:
0.2 +>.dur \test;
//:
2.0 +>.dur \test;
//:
\set +>.type \test;
//:
\note +>.type \test;
//: ================ Here we try out low-level control of monophonic playing with note types:
(degree: Pbrown (1, 20, 1, inf), type: Pseq ([\monoNote, Pn (\set, 5), \monoOff], inf), dur: 0.25) +!> \test;
//: every \monoNote plays a note of fixed pitch? Why?
(degree: Pbrown (1, 20, 1, inf), type: Pseq ([\monoNote, Pn (\set, 2), \monoOff], inf), dur: 0.25) +!> \test;
//: plus the \monoNote's frequency is the default frequency 440:
(freq: Prand ([440, 880], inf), type: Pseq ([\monoNote, Pn (\set, 2), \monoOff], inf), dur: 0.5) +!> \test;
// it seems that the \monoNote type function does not use freq, although it accesses it: 
monoNote:	#{ |server|
	var bndl, id, ids, addAction, f;
	addAction = Node.actionNumberFor(~addAction);
	~freq = ~detunedFreq.value;
	f = ~freq;
	// neither f nor ~freq are used beyond this point.
	// can ~msgFunc address these? Apparently not?
	~amp = ~amp.value;

	bndl = ( [9 /* \s_new */, ~instrument, ids, addAction, ~group.asControlInput]
		++ ~msgFunc.valueEnvir).flop;
	bndl.do { | b |
		id = server.nextNodeID;
		ids = ids.add(id);
		b[2] = id;
	};

	if ((addAction == 0) || (addAction == 3)) {
		bndl = bndl.reverse;
	};
	bndl = bndl.collect(_.asOSCArgArray);
	~schedBundle.value(~lag, ~timingOffset, server, *bndl);
	~updatePmono.value(ids, server);
}

*/
//: Contrasting the above to Pmono pattern type - from Help files:
p = Pn (Pmono (\default, \dur, 0.15, \degree, Pbrown(-5, 30, 3, 3)), inf).play;
//:
p.stop
//: ================ Define alternatives for pMono?
/* I could not store a key for the next event through the current event play function
	This makes sense: Apparently the event is always made new, no state is stored between events. 
	I do not understand how ~id is used in set event type even though when I post it it is nil.

	An alternative is to use Notification to send data to synths that are attached to the EventStreamPlayer.

*/

set: #{|server|
	var freqs, lag, dur, strum, bndl, msgFunc;
	freqs = ~freq = ~detunedFreq.value;
	~server = server;
	~amp = ~amp.value;

	if(~args.size == 0) {
		msgFunc = ~getMsgFunc.valueEnvir;
		bndl = msgFunc.valueEnvir;
	} {
		bndl = ~args.envirPairs;
	};
	bndl = ([15 /* \n_set */, ~id] ++  bndl).flop.asOSCArgBundle;
	~schedBundleArray.value(~lag, ~timingOffset, server, bndl, ~latency);
}

//: or to attach EventStream instances to a task and play events generated by them:
r = {
	var es;
	es = {EventPattern ((degree: Prand ((0..20), inf), dur: 0.1)).asStream} ! 4;
	loop {
		es do: { | e | e.next.play};
		0.1.wait;
	}
}.fork;

//:
r.stop;
//:
Event.parentEvents.default.eventTypes [\pmono1] = {

}
//:
Pbind (\type, \pmono1, \degree, Pseq ((0..20), inf)).play;
//:
(type: \pmono1, degree: Pseq ((0..20), inf)) +> \e;
//:

(degree: 30).play;
//: ================================================================
//: An event type that pushes values to an environment:
Event.parentEvents.default.eventTypes [\envEvent] = #{|server|
	
	var envir;
	~freq = ~detunedFreq.value;

	// msgFunc gets the synth's control values from the Event
	~amp = ~amp.value;
	~sustain = ~sustain.value;
	envir = ~envir;
	~getMsgFunc.valueEnvir.valueEnvir pairsDo: { | key, val | envir [key] = val };
	currentEnvironment pairsDo: { | key, val |
		if (key != \envir) { envir [key] = val };
	}
};
//:
\default +> \default;
//:
EventPattern ((type: \envEvent, dur: 0.1, freq: Pwhite (1000, 2000, inf), envir: currentEnvironment)).play;
//:
\window.vlayout (
	CSlider (\freq)
).front;
//:
~freq = 100;
//:
\envir.push;
//:
currentEnvironment;
//:
{ | freq = 400 | SinOsc.ar (freq, 0, 0.1 )}.eplay;
//:
(degree: Pwhite (20, 30, inf), dur: 0.1).eplay;
//:
(degree: Pbrown (0, 30, 2, inf), dur: 0.1).eplay;
{ | freq = 400 | SinOsc.ar (freq, 0, 0.1 )}.eplay;
\window.vlayout (CSlider (\freq)).front;
//:
a = EventPattern ((dur: 1)).play;
a addDependant: { | ... args | args.postln; };
//:
a.stop;
//:
{ | freq = 400 | SinOsc.ar (freq, 0, 0.1) }.eplay;
(dur: 0.001, freq: Pbrown (400, 4000, 30, inf)).eplay;
//:
(dur: Pfunc ({0.001 exprand: 0.5}), freq: Pbrown (400, 4000, 300, inf)).eplay;
//:
(dur: 0.5, degree: Pbrown (0, 20, 2, inf)).eplay;
//:
(dur: 0.5, degree: Pbrown (0, 20, 2, inf), func: \start).eplay;
//:
currentEnvironment.changed (\synth, \stop);
//:
currentEnvironment addDependant: { | ... args | args.postln; };